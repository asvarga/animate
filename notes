

1. Do math with arbitrary objects by deferring the function application until numbers are found: wrapped.bind(unary function)
2. Do lerping stuff





A Lerp is a pair of elements and a function: time -> [0, 1]
Any function applied to a Lerp gets postponed


Are Lerps basically split pointers?






ax^3 + bx^2 + cx
3ax^2 + 2bx + c

a + b = 1
3a + 2b = 0

a = -2
b = 3




ax^5 + bx^4 + cx^3 + dx^2 + ex + f
5ax^4 + 4bx^3 + 3cx^2 + 2dx + e
20ax^3 + 12bx^2 + 6cx + 2d

e = f = 0
a + b + c + d = 1
5a + 4b + 3c + 2d = 0


d = e = f = 0
a + b + c = 1
5a + 4b + 3c = 0
20a + 12b + 6c = 0







CREATE WHOLE INTERPRETED LANGUAGE THAT SELF PRUNES AS IT RUNS
- HAVE SEVERAL FORMS
- INCLUDING A GETTIME FORM
- AND A LERP FORM (LIKE A STRANGE IF-THEN-ELSE)

- NODES KEEP TRACK OF IF THEY ARE FINAL AND IF THEY ARE CONSTANT

- CAN WE GIVE HINTS TO THE JIT COMPILER TO DO THIS FOR US?
	- PROBABLY NOT, IT IS DUMB

- DON'T BE AS OBJECT ORIENTED; SEPARATE THE INTERPRETER FROM AST

- EVENTUALLY USE ANIMATION TO VISUALIZE SELF PRUNING...




- Simplify the language
	- no functions!
	- functions just behave like ma  (th equations?)







- object orient: put methods objects

- neaten up
- rename things and functions
- caching for Nodes
	- Nodes should be time-pure by definition
- make independent of create.js or any other clock thing
	- default to some vanilla ticker
- avoid name conflicts (like type property)
- neaten up switch(type) logic
- come up with cool name (animonad, super position)
- solve bidirectional update issue?
- more types of things
- APP(js, DUAL(x, y)) should *become* DUAL(APP(f, x), APP(f, y)) once and evaluate that every frame
- add edges to tree in demo



x consider interpreter approach again?
	x this allows P(O(O(O))) instead of P(O(P(O(P(O))))) where P=proxy and O=object
	x might allow quotes and variables and such
		x interpreter could return (value, simplified subexpressions) to avoid mutating the AST in place
	*** avoiding mutation in place simplifies the interpreter
		x each element IS a function that returns (value, simplified self)
			- or should these two roles be separated?
		- interpreter still needed for variables
		- need objects with valueOf() to treat AST elements as simple values and simplify them
! oy dis dont work becuz applying arbitrary js to lang things is out of interpreter's control, so every lang object must be wrapped to catch every interaction with js
	- don't bother with variables, just use simple expressions
	- don't even need 'let' because caching do dat automatically









